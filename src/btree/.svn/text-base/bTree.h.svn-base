#include "../bulk_storage/bulk_storage.h"

#ifndef  __BTREE__H
#define  __BTREE__H
#ifndef  TRUE
typedef int  BOOL;
#define  TRUE    1
#define  FALSE   0
#endif  /* TRUE */

#define LT -1
#define EQ 0
#define GT 1

/**
   \defgroup BTree
   @{
   B-Trees provide indexing of one dimensional data.

    \ingroup Indices
*/

/**
   \ingroup BTree
*/
struct  btree_node {
  off_t left, right, father;
  //struct btree_node *node_init (int );
  //int parent;
  //off_t dbObject;
  off_t  data;
};



/**
   \ingroup BTree
*/
struct btree {
  struct store * oStore;
  struct store * nStore;
  off_t entries_num;
  off_t root;
  int (*compare)(const void*, const void*);
};


/*
   Create a new bTree backed by two memStore stores.
   
   @see store_new_memory
   \ingroup BTree
*/
struct btree * btree_new_memory(size_t objectSize);

/*
   Create a new bTree backed by two cacheStore stores.  

   @see store_new_cached
   \ingroup BTree
*/
struct btree * btree_new_cached(struct store * store, const char * nFile, const char * nFat,
				size_t cacheSize, int (*compare)(const void*, const void*));

/**
   \ingroup BTree
*/
void   btree_close( struct btree * p_btree );


/**
   \ingroup BTree
*/
void   btree_init( struct btree * p_btree );
/**
   \ingroup BTree
*/
void btree_insert(struct btree * p_btree, off_t data);
/**
   \ingroup BTree
*/
BOOL   btree_delete( struct btree * p_btree, void* data );
/**
   \ingroup BTree
*/
int btree_find (const struct btree * tree, void* find_data);
/**
   \ingroup BTree
*/
void btree_query (const struct btree * tree, void* find_data, void*(*handler)(const void*,void*), void * handler_state);
/**
   \ingroup BTree
*/
void   btree_print( const struct btree  * p_btree );

/**
   @}
*/
#else   /* __BTREE__H */
#error  Header file btree.h included twice
#endif  /* __BTREE__H */
